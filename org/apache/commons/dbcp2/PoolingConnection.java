package org.apache.commons.dbcp2;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.NoSuchElementException;
import org.apache.commons.pool2.KeyedObjectPool;
import org.apache.commons.pool2.KeyedPooledObjectFactory;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.DefaultPooledObject;

public class PoolingConnection
  extends DelegatingConnection<Connection>
  implements KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement>
{
  private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> _pstmtPool = null;
  
  public PoolingConnection(Connection c)
  {
    super(c);
  }
  
  public void setStatementPool(KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool)
  {
    this._pstmtPool = pool;
  }
  
  public synchronized void close()
    throws SQLException
  {
    try
    {
      if (null != this._pstmtPool)
      {
        KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> oldpool = this._pstmtPool;
        this._pstmtPool = null;
        try
        {
          oldpool.close();
        }
        catch (RuntimeException e)
        {
          throw e;
        }
        catch (Exception e)
        {
          throw new SQLException("Cannot close connection", e);
        }
      }
    }
    finally
    {
      try
      {
        getDelegateInternal().close();
      }
      finally
      {
        setClosedInternal(true);
      }
    }
  }
  
  public PreparedStatement prepareStatement(String sql)
    throws SQLException
  {
    if (null == this._pstmtPool) {
      throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
    }
    try
    {
      return (PreparedStatement)this._pstmtPool.borrowObject(createKey(sql));
    }
    catch (NoSuchElementException e)
    {
      throw new SQLException("MaxOpenPreparedStatements limit reached", e);
    }
    catch (RuntimeException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new SQLException("Borrow prepareStatement from pool failed", e);
    }
  }
  
  public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
    throws SQLException
  {
    if (null == this._pstmtPool) {
      throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
    }
    try
    {
      return (PreparedStatement)this._pstmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
    }
    catch (NoSuchElementException e)
    {
      throw new SQLException("MaxOpenPreparedStatements limit reached", e);
    }
    catch (RuntimeException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new SQLException("Borrow prepareStatement from pool failed", e);
    }
  }
  
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
    throws SQLException
  {
    if (null == this._pstmtPool) {
      throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
    }
    try
    {
      return (PreparedStatement)this._pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
    }
    catch (NoSuchElementException e)
    {
      throw new SQLException("MaxOpenPreparedStatements limit reached", e);
    }
    catch (RuntimeException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new SQLException("Borrow prepareStatement from pool failed", e);
    }
  }
  
  public CallableStatement prepareCall(String sql)
    throws SQLException
  {
    try
    {
      return (CallableStatement)this._pstmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
    }
    catch (NoSuchElementException e)
    {
      throw new SQLException("MaxOpenCallableStatements limit reached", e);
    }
    catch (RuntimeException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new SQLException("Borrow callableStatement from pool failed", e);
    }
  }
  
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency)
    throws SQLException
  {
    try
    {
      return (CallableStatement)this._pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
    }
    catch (NoSuchElementException e)
    {
      throw new SQLException("MaxOpenCallableStatements limit reached", e);
    }
    catch (RuntimeException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new SQLException("Borrow callableStatement from pool failed", e);
    }
  }
  
  protected PStmtKey createKey(String sql, int autoGeneratedKeys)
  {
    String catalog = null;
    try
    {
      catalog = getCatalog();
    }
    catch (SQLException e) {}
    return new PStmtKey(normalizeSQL(sql), catalog, autoGeneratedKeys);
  }
  
  protected PStmtKey createKey(String sql, int resultSetType, int resultSetConcurrency)
  {
    String catalog = null;
    try
    {
      catalog = getCatalog();
    }
    catch (SQLException e) {}
    return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency);
  }
  
  protected PStmtKey createKey(String sql, int resultSetType, int resultSetConcurrency, StatementType stmtType)
  {
    String catalog = null;
    try
    {
      catalog = getCatalog();
    }
    catch (SQLException e) {}
    return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, stmtType);
  }
  
  protected PStmtKey createKey(String sql)
  {
    String catalog = null;
    try
    {
      catalog = getCatalog();
    }
    catch (SQLException e) {}
    return new PStmtKey(normalizeSQL(sql), catalog);
  }
  
  protected PStmtKey createKey(String sql, StatementType stmtType)
  {
    String catalog = null;
    try
    {
      catalog = getCatalog();
    }
    catch (SQLException e) {}
    return new PStmtKey(normalizeSQL(sql), catalog, stmtType, null);
  }
  
  protected String normalizeSQL(String sql)
  {
    return sql.trim();
  }
  
  public PooledObject<DelegatingPreparedStatement> makeObject(PStmtKey key)
    throws Exception
  {
    if (null == key) {
      throw new IllegalArgumentException("Prepared statement key is null or invalid.");
    }
    if ((null == key.getResultSetType()) && (null == key.getResultSetConcurrency()) && (null == key.getAutoGeneratedKeys()))
    {
      if (key.getStmtType() == StatementType.PREPARED_STATEMENT)
      {
        PoolablePreparedStatement pps = new PoolablePreparedStatement(getDelegate().prepareStatement(key.getSql()), key, this._pstmtPool, this);
        
        return new DefaultPooledObject(pps);
      }
      return new DefaultPooledObject(new PoolableCallableStatement(getDelegate().prepareCall(key.getSql()), key, this._pstmtPool, this));
    }
    if ((null == key.getResultSetType()) && (null == key.getResultSetConcurrency()))
    {
      PoolablePreparedStatement pps = new PoolablePreparedStatement(getDelegate().prepareStatement(key.getSql(), key.getAutoGeneratedKeys().intValue()), key, this._pstmtPool, this);
      
      return new DefaultPooledObject(pps);
    }
    if (key.getStmtType() == StatementType.PREPARED_STATEMENT)
    {
      PoolablePreparedStatement pps = new PoolablePreparedStatement(getDelegate().prepareStatement(key.getSql(), key.getResultSetType().intValue(), key.getResultSetConcurrency().intValue()), key, this._pstmtPool, this);
      
      return new DefaultPooledObject(pps);
    }
    return new DefaultPooledObject(new PoolableCallableStatement(getDelegate().prepareCall(key.getSql(), key.getResultSetType().intValue(), key.getResultSetConcurrency().intValue()), key, this._pstmtPool, this));
  }
  
  public void destroyObject(PStmtKey key, PooledObject<DelegatingPreparedStatement> p)
    throws Exception
  {
    ((DelegatingPreparedStatement)p.getObject()).getInnermostDelegate().close();
  }
  
  public boolean validateObject(PStmtKey key, PooledObject<DelegatingPreparedStatement> p)
  {
    return true;
  }
  
  public void activateObject(PStmtKey key, PooledObject<DelegatingPreparedStatement> p)
    throws Exception
  {
    ((DelegatingPreparedStatement)p.getObject()).activate();
  }
  
  public void passivateObject(PStmtKey key, PooledObject<DelegatingPreparedStatement> p)
    throws Exception
  {
    DelegatingPreparedStatement dps = (DelegatingPreparedStatement)p.getObject();
    dps.clearParameters();
    dps.passivate();
  }
  
  public String toString()
  {
    if (this._pstmtPool != null) {
      return "PoolingConnection: " + this._pstmtPool.toString();
    }
    return "PoolingConnection: null";
  }
  
  protected static enum StatementType
  {
    CALLABLE_STATEMENT,  PREPARED_STATEMENT;
    
    private StatementType() {}
  }
}
